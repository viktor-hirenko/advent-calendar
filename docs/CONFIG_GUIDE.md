# Посібник з конфігурації (`app-config.json`)

## 1. Призначення
Файл `src/data/app-config.json` є єдиним джерелом контенту для календаря. Він описує:
- тексти й локалізації;
- набір задач на кожен день;
- зовнішні посилання та зображення;
- технічні параметри періоду, часових поясів та розкладки.

Зміна JSON не потребує збірки, але рекомендується запускати `npm run validate-config` після редагування.

## 2. Загальна структура
```jsonc
{
  "calendar": {
    /* Контент інтерфейсу та задачі */
  },
  "config": {
    /* Технічні налаштування календаря */
  }
}
```

### 2.1 Мовні ключі
Усі локалізовані поля — це обʼєкти з мовами (en, de, fr, it, es, pt). Обовʼязковий щонайменше `en`. Якщо переклад відсутній, клієнт автоматично підставить англійську версію.

## 3. Секція `calendar`

| Ключ | Тип | Опис |
|------|-----|------|
| `title`, `description` | `LocalizedText` | Головний заголовок та опис блоку. Використовуються у банері та `<head>`. |
| `labels.promotion` | `LocalizedText` | Текст бейджа над календарем (наприклад, “Promotion”). |
| `links.primary` | `string \| LocalizedText` | Глобальний URL для CTA-кнопок. Значення задачі (`task.targetUrl`) перекриває його, якщо задане. |
| `images.banner` | текстові ключі файлів | Шляхи до вебp-зображень для банера: `mobile`, `tablet`, `desktop`, `large`, `ultra`, `extraSmall`; та обовʼязковий `alt` з локалізаціями. Файли повинні існувати у `src/assets/images`. |
| `images.decoration.ultra` | `string` | Декоративний елемент для надвеликих екранів (опціонально). |
| `images.disabledTaskIcon` | `string` | Іконка для заблокованих задач. |
| `disabledTask.title`, `disabledTask.buttonText` | `LocalizedText` | Шаблони для картки, якщо день ще не відкрито. Дата підставляється автоматично (`formatDisabledTaskDate`). |
| `tasks[]` | масив обʼєктів | Масив задач у порядку календаря. Повинен містити стільки елементів, скільки днів у діапазоні `startDate` → `endDate`. Якщо задач менше, система циклічно повторюватиме їх (про це зʼявиться попередження у консолі). |
| `tasks[].id` | `string` (унікальний) | Використовується для `key` та аналітики. |
| `tasks[].title`, `description`, `buttonText` | `LocalizedText` | Контент картки. В описі дозволені базові HTML-теги, які проходять через `DOMPurify` (`<strong>` за замовчуванням). |
| `tasks[].targetUrl` | `string` | Індивідуальний URL для кнопки (опційно). |
| `termsButton` | `LocalizedText` | Текст кнопки переходу до умов у футері. Подія `terms-click` підіймається у батьківський компонент. |
| `taskStatus.finishesIn`, `finished`, `dayUnit` | `LocalizedText` | Підписи для таймера та бейджів завершених задач. `dayUnit` — суфікс до кількості днів (напр., “d”, “Tg”). |

### 3.1 Робота з завданнями
- **Порядок важливий**: перший елемент масиву відповідає дню `startDate`, другий — `startDate + 1` і т.д.
- **Кількість**: скрипт `useAppConfig` підказує у консолі, якщо кількість задач не дорівнює довжині періоду. У продакшені це лише попередження, але рекомендується підтримувати паритет.
- **Мультимовність**: обовʼязково перекладати всі ключі із `supportedLanguages`. Відсутні переклади призведуть до fallback на англійську.
- **HTML у описах**: дозволено лише теги, які пропускає `sanitizeHtml` (`DOMPurify` з whitelisting). Для додавання інших тегів оновіть `src/utils/sanitizeHtml.ts`.

## 4. Секція `config`

| Ключ | Тип | Обовʼязково | Опис |
|------|-----|-------------|------|
| `startDate` | `YYYY-MM-DD` | так | Початок промокампанії. Валидація через `validate-config.mjs`. |
| `endDate` | `YYYY-MM-DD` | так | Кінець промокампанії (включно). |
| `timeMode` | `'local' \| 'utc'` | ні (default `local`) | Режим обчислення "сьогоднішнього" дня та таймерів. `local` — використовує таймзону користувача; `utc` — фіксований UTC (рекомендовано, якщо імідж-бонус має працювати одночасно для всіх регіонів). |
| `alignByWeekday` | `boolean` | ні (default `false`) | Якщо `true`, сітка в десктопі вирівнюється по днях тижня (плейсхолдери перед початком місяця). Працює тільки на екранах `>= 768px` через `useMediaQuery`. |
| `firstDayOfWeek` | `'auto' \| 'monday' \| 'sunday'` | ні (default `auto`) | Визначає, з якого дня починається тиждень у вирівняній сітці. `auto` використовує `Intl.Locale.weekInfo` з fallback'ом (US/CA/PH → неділя, інші → понеділок). |
| `defaultLanguage` | `string` | так | Мова за замовчуванням (має збігатися з однією із `supportedLanguages`). Використовується, якщо параметр `language` не переданий і браузер не підтримує потрібну мову. |
| `supportedLanguages[]` | масив `string` | так | Допустимі мови інтерфейсу. Кожна мова повинна мати переклад у `calendar.*`. |
| `ui` | `object` | ні | Керування видимістю UI-секцій (детальніше див. секцію 4.3). |

### 4.3 Секція `config.ui` — керування видимістю UI-елементів

Секція `config.ui` дозволяє гнучко керувати відображенням різних частин інтерфейсу без зміни коду. Всі поля опціональні, за замовчуванням всі секції видимі.

```jsonc
{
  "config": {
    "ui": {
      "introSection": {
        "visible": true,      // Показувати секцію з заголовком та описом
        "tagLabel": true,     // Показувати бейдж "Promotion"
        "title": true,        // Показувати заголовок календаря
        "description": true   // Показувати опис календаря
      },
      "calendarSection": {
        "visible": true,      // Показувати секцію календаря
        "tasksPanel": true    // Показувати панель з карточками задач
      },
      "footerSection": {
        "visible": true,      // Показувати футер
        "termsButton": true,  // Показувати кнопку "Terms and Conditions"
        "termsModal": {
          "visible": true     // Показувати модальне вікно з умовами
        }
      }
    }
  }
}
```

**Приклади використання:**

1. **Мінімальний календар** (тільки сітка днів):
```json
{
  "ui": {
    "introSection": { "visible": false },
    "calendarSection": { "visible": true, "tasksPanel": false },
    "footerSection": { "visible": false }
  }
}
```

2. **Календар без умов використання**:
```json
{
  "ui": {
    "footerSection": {
      "visible": true,
      "termsButton": false,
      "termsModal": { "visible": false }
    }
  }
}
```

3. **Тільки задачі без календаря**:
```json
{
  "ui": {
    "introSection": { "visible": true },
    "calendarSection": { "visible": false },
    "footerSection": { "visible": true }
  }
}
```

### 4.4 Логіка `alignByWeekday` та плейсхолдери

Параметр `alignByWeekday` керує вирівнюванням сітки календаря по днях тижня. Коли він увімкнений:

1. **Умови активації:**
   - `alignByWeekday: true` в конфігурації
   - Ширина екрану `>= 768px` (перевіряється через `useMediaQuery('(min-width: 768px)')`)

2. **Генерація плейсхолдерів:**
   - Система автоматично додає невидимі плейсхолдери на початку місяця
   - Кількість плейсхолдерів залежить від дня тижня першого дня місяця
   - Плейсхолдери мають `isPlaceholder: true`, `opacity: 0`, `pointer-events: none`
   - Вони займають місце в CSS Grid, але не є інтерактивними

3. **Приклад:**
   Якщо місяць починається з середи, і `firstDayOfWeek: 'monday'`, то буде додано 2 плейсхолдери (понеділок, вівторок), щоб середа була в правильній колонці.

4. **Відключення на мобільних:**
   На екранах `< 768px` плейсхолдери не генеруються, дні відображаються послідовно без вирівнювання по тижнях.

5. **Налагодження:**
   Якщо плейсхолдери не відображаються або сітка ламається:
   - Перевірте, що `alignByWeekday: true`
   - Перевірте ширину екрану (має бути `>= 768px`)
   - Перевірте в DevTools, що плейсхолдери присутні в DOM з класом `.calendar-days__placeholder`
   - Переконайтеся, що немає CSS правил, які приховують плейсхолдери через `display: none`

### 4.5 Валідація конфігурації
Скрипт `npm run validate-config` перевіряє:
- коректність дат (`startDate <= endDate`, валідні календарні дні);
- довжину промоперіоду (видає попередження, якщо більше 92 днів);
- правильність значення `firstDayOfWeek`.

### 4.2 Взаємодія з query-параметрами
Компосабл `useQueryParams` підтримує:
- `?language=xx` — примусова мова, якщо входить у `supportedLanguages`;
- `?testDate=YYYY-MM-DD` — фіксація “сьогоднішнього” дня для QA/демо (і таймер, і активні дні використовують цю дату);
- `?debug=true` — прапорець для умовної логіки (поки що не використовується в UI, але доступний у composable).

Порядок вибору мови:
1. `?language`;
2. значення, виставлене в `<html lang="…">` (браузер/сервер);
3. `defaultLanguage` з конфігу.

## 5. Зображення та шляхи
- Усі локальні файли мають бути розміщені у `src/assets/images`. Під час збірки Vite експортує їх до `/assets/...`.
- `resolveImg` працює і з абсолютними (`https://...`) шляхами, і з логічними ключами типу `banners/default/xxx.webp`.
- Для нових ресурсів варто запускати `npm run images:webp`, щоб створити WebP-версії.

## 6. Робочий процес оновлення контенту
1. Додайте/оновіть тексти у `calendar.*` та переконайтеся, що вони присутні в усіх мовах.
2. Оновіть `tasks[]`, дотримуючись кількості днів. Якщо зʼявилися нові типи бонусів, використовуйте `id` для інтеграцій.
3. Переконайтеся, що `startDate` та `endDate` відповідають кількості елементів у `tasks`.
4. Запустіть:
   ```bash
   npm run validate-config
   npm run tokens:build          # якщо змінювали тему
   npm run images:webp           # якщо додали нові PNG/JPG
   ```
5. Перевірте у браузері з параметром `?testDate` для критичних сценаріїв (відкриття майбутніх та минулих днів).

Дотримання цих правил гарантує стабільну роботу календаря у продакшені без додаткових правок коду.
